You are developing a simple controller for an arbitrary robot that you must identify. This robot is controlled by an onboard "companion" computer that may or may not have sufficient dependencies installed.

The steps should be taken as follows: 1.) Identify the robot 2.) Identify the high-level dependencies on the companion 3.) Generate simulation environment using Docker and Gazebo 4.) Build robot controller 5.) Iteratively test in simulation environment

IMPORTANT: Wait for user approval before proceeding to each new step.

Step 1.) Identify the robot in the "images" directory. Also use the SBOM in the "sbom" directory. This is the target robot for which you will build a controller. Examine images to identify: robot type (ground/aerial/marine/manipulator), manufacturer/model, visible sensors (cameras, LIDAR, IMU), actuators (wheels, propellers, joints). Determine the likely control interface (differential drive, ackermann, holonomic, etc.) and expected ROS message types (likely geometry_msgs/Twist for velocity control). Present your findings and wait for user approval before proceeding.

Step 2.) Check the SBOM in the "sbom" directory. Identify the dependencies available on the companion computer. Look for critical dependencies including: ROS version (ROS1/ROS2, distribution name), Gazebo version, Python version, and relevant ROS packages. Compare what the robot needs versus what's installed in the SBOM to identify any gaps. Present your findings and wait for user approval before proceeding.

Step 3.) Check Dockerfile and Dockerfile.extended. If Dockerfile is missing crucial software for the robot operation that has been identified in the SBOM, add it to the Dockerfile.extended (only modify Dockerfile.extended, never the base Dockerfile). Add missing packages identified in Step 2 that are crucial for robot operation (ROS packages, Gazebo plugins, drivers). Make sure that this working directory is mounted for persistent code development, then build the image using the Makefile. Execute commands inside the container programmatically using docker exec. Verify by running basic commands like rosversion -d and gazebo --version. Wait for user approval before proceeding.

Step 4.) Verify that the container is working by executing commands programmatically inside it. Spin up an instance of Gazebo to make sure it is also working. If a model of the robot is not present, first search for an existing model online (priority: Gazebo model database, GitHub, ROS wiki/packages). If no suitable model is found online, generate a basic URDF/SDF yourself with simplified geometry (boxes/cylinders) matching the robot's kinematic structure and joint configuration. With that done, build a simple robot controller that uses the ROS teleop_twist_keyboard package - create a ROS node that subscribes to /cmd_vel and publishes to the robot's control topic. Wait for user approval before proceeding.

Step 5.) Verify in Gazebo that directions are correct, ie., forward is positive X, right rotation is clockwise about Z. Test commands: forward (+X), backward (-X), rotate left (+Z), rotate right (-Z). Generate output to the "logs" directory in JSON format to confirm controller behavior and enable feedback loops for iterative improvement. Each test run should produce a timestamped JSON log file containing command inputs, expected behaviors, observed behaviors, and pass/fail status (example: {"timestamp": "...", "command": {"linear.x": 1.0, "angular.z": 0}, "expected": "forward motion", "observed": "robot moved forward", "pass": true}). Pass criteria: robot motion matches expected direction for each command. Iterate as needed based on log analysis - if directions are incorrect, fix controller/model transforms and re-test until all pass.
